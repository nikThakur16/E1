import BackButton from "../components/popup/BackButton";
import { useNavigate } from "react-router";
import Heading from "../components/popup/Heading";
import { Stepper } from "../components/popup/Stepper";
import { useState, useEffect, useRef } from "react";

const AudioProcessing = () => {
  const navigate = useNavigate();
  const [currentIcon, setCurrentIcon] = useState("/popup/RS1.svg");
  const [currentDescription, setCurrentDescription] = useState("Your voice, our focus - detecting tone and cutting out the noise.");
  const [stopLoader, setStopLoader] = useState(true);
  
  // Audio-related state
  const [audioData, setAudioData] = useState<string | null>(null);
  const [audioUrl, setAudioUrl] = useState<string | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [audioSize, setAudioSize] = useState<string>("0 MB");
  const audioRef = useRef<HTMLAudioElement>(null);

  const stepIcons = ["/popup/RS1.svg", "/popup/RS2.svg", "/popup/RS3.svg"];
  const description = [
    "Your voice, our focus - detecting tone and cutting out the noise.",
    "Every word matters - converting voice to text.",
    "Extracting what matters - your smart summary is on the way."
  ];

  // Load recorded audio data on component mount
  useEffect(() => {
    const loadRecordedAudio = async () => {
      try {
        console.log('ðŸŽµ Loading recorded audio data...');
        
        if (chrome?.storage?.local) {
          const result = await chrome.storage.local.get(['lastRecordingData', 'recordingTimestamp']);
          
          if (result.lastRecordingData) {
            console.log('âœ… Found recorded audio data:', {
              dataLength: result.lastRecordingData.length,
              timestamp: result.recordingTimestamp,
              estimatedSize: `${(result.lastRecordingData.length * 0.75 / 1024 / 1024).toFixed(2)} MB`
            });
            
            setAudioData(result.lastRecordingData);
            setAudioSize(`${(result.lastRecordingData.length * 0.75 / 1024 / 1024).toFixed(2)} MB`);
            
            // Convert base64 to blob and create URL
            try {
              const binaryString = atob(result.lastRecordingData);
              const bytes = new Uint8Array(binaryString.length);
              for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
              }

              let blob;
              try {
                blob = new Blob([bytes], { type: "audio/webm;codecs=opus" });
              } catch {
                blob = new Blob([bytes], { type: "audio/webm" });
              }

              const url = URL.createObjectURL(blob);
              setAudioUrl(url);
              
              console.log('ðŸŽ§ Audio URL created for playback:', {
                blobSize: blob.size,
                blobType: blob.type,
                url: url.substring(0, 50) + '...'
              });
              
            } catch (error) {
              console.error('âŒ Error processing audio data:', error);
            }
          } else {
            console.warn('âš ï¸ No recorded audio data found');
          }
        }
      } catch (error) {
        console.error('âŒ Error loading recorded audio:', error);
      }
    };

    loadRecordedAudio();
    
    // Cleanup audio URL on unmount
    return () => {
      if (audioUrl) {
        URL.revokeObjectURL(audioUrl);
      }
    };
  }, []);

  // Audio player controls
  const togglePlay = () => {
    const audio = audioRef.current;
    if (!audio) return;

    if (isPlaying) {
      audio.pause();
      setIsPlaying(false);
    } else {
      audio.play().then(() => {
        setIsPlaying(true);
      }).catch((error) => {
        console.error('Error playing audio:', error);
      });
    }
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  // Audio event handlers
  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    const handleLoadedMetadata = () => {
      setDuration(audio.duration);
    };

    const handleTimeUpdate = () => {
      setCurrentTime(audio.currentTime);
    };

    const handleEnded = () => {
      setIsPlaying(false);
      setCurrentTime(0);
    };

    audio.addEventListener('loadedmetadata', handleLoadedMetadata);
    audio.addEventListener('timeupdate', handleTimeUpdate);
    audio.addEventListener('ended', handleEnded);

    return () => {
      audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
      audio.removeEventListener('timeupdate', handleTimeUpdate);
      audio.removeEventListener('ended', handleEnded);
    };
  }, [audioUrl]);

  return (
    <div className="flex flex-col items-center justify-center bg-[#F4F8FF] px-4 py-6">
      <div className="w-full">
        <BackButton handleBack={() => navigate(-1)} />
      </div>

      <div className="px-4 w-full">
        <div className="w-full text-center">
          <Heading title="Processing Recording" />
          <p className="font-[400] text-[#4B5563] text-[16px] text-center w-[60%] mx-auto">
            {currentDescription}
          </p>
        </div>

        {/* Recorded Audio Player */}
        {audioUrl && (
          <div className="w-full max-w-md mx-auto mb-6 p-4 bg-white rounded-xl shadow-md">
            <div className="flex items-center justify-between mb-3">
              <h3 className="text-lg font-semibold text-[#1F2937]">ðŸŽµ Your Recording</h3>
              <span className="text-sm text-[#6B7280]">{audioSize}</span>
            </div>
            
            {/* Audio Element */}
            <audio ref={audioRef} src={audioUrl} preload="metadata" />
            
            {/* Audio Controls */}
            <div className="space-y-3">
              {/* Play/Pause Button */}
              <div className="flex items-center justify-center">
                <button
                  onClick={togglePlay}
                  className="flex items-center justify-center w-14 h-14 bg-[#3F7EF8] hover:bg-[#2563eb] text-white rounded-full transition-colors cursor-pointer"
                  disabled={!audioUrl}
                >
                  {isPlaying ? (
                    <svg className="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
                      <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
                    </svg>
                  ) : (
                    <svg className="w-6 h-6" fill="currentColor" viewBox="0 0 24 24">
                      <path d="M8 5v14l11-7z"/>
                    </svg>
                  )}
                </button>
              </div>
              
              {/* Progress Bar */}
              <div className="space-y-1">
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div 
                    className="bg-[#3F7EF8] h-2 rounded-full transition-all duration-100"
                    style={{ width: duration > 0 ? `${(currentTime / duration) * 100}%` : '0%' }}
                  />
                </div>
                <div className="flex justify-between text-xs text-[#6B7280]">
                  <span>{formatTime(currentTime)}</span>
                  <span>{formatTime(duration)}</span>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* No Audio Message */}
        {!audioUrl && audioData === null && (
          <div className="w-full max-w-md mx-auto mb-6 p-4 bg-yellow-50 border border-yellow-200 rounded-xl">
            <div className="flex items-center space-x-2">
              <svg className="w-5 h-5 text-yellow-600" fill="currentColor" viewBox="0 0 24 24">
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
              </svg>
              <span className="text-sm text-yellow-800">Loading recorded audio...</span>
            </div>
          </div>
        )}

        {/* Error Message */}
        {!audioUrl && audioData !== null && (
          <div className="w-full max-w-md mx-auto mb-6 p-4 bg-red-50 border border-red-200 rounded-xl">
            <div className="flex items-center space-x-2">
              <svg className="w-5 h-5 text-red-600" fill="currentColor" viewBox="0 0 24 24">
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
              </svg>
              <span className="text-sm text-red-800">Error loading audio. Please try recording again.</span>
            </div>
          </div>
        )}

        {/* Loader with dynamic icon */}
        <div className="w-full flex justify-center my-6">
          <div className="relative flex items-center justify-center">
            <div className={`absolute h-28 w-28 rounded-full border-4 border-blue-500 border-t-transparent ${stopLoader ? "block" : "hidden"} animate-spin`}></div>
            <img src={currentIcon} alt="step icon" className="h-24 w-24" />
          </div>
        </div>

        <Stepper
          steps={[
            {
              title: "Processing Audio",
              description: "Analyzing your recorded audio content.",
            },
            {
              title: "Speech to Text",
              description: "Converting your voice to readable text.",
            },
            {
              title: "AI Summary",
              description: "Creating a smart summary of your recording.",
            },
          ]}
          title="Steps to Process your Audio"
          duration={2500}
          autoStart={true}
          onStepChange={(stepIndex) => {
            setCurrentIcon(stepIcons[stepIndex + 1] || stepIcons[stepIcons.length - 1]);
            setCurrentDescription(description[stepIndex + 1] || description[description.length - 1]);
          }}
          onComplete={() => {
            setStopLoader(false);
          }}
        />
      </div>
    </div>
  );
};

export default AudioProcessing;
